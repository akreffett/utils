#MAEC Malware Action Class

#Copyright (c) 2012, The MITRE Corporation
#All rights reserved.

#Compatible with MAEC v3.0
#Last updated 01/16/2013

import maec_bundle_3_0 as bundle_binding

class malware_action:
    def __init__(self):
        pass

    #Build the Action from the input dictionary
    @classmethod
    def create_from_dict(cls, action_attributes_dict):
        action = bundle_binding.MalwareActionType()
        associated_objects = bundle_binding.cybox_core_1_0.AssociatedObjectsType()
        for key, value in action_attributes_dict.items():
            if key == 'undefined_name':
                action.set_undefined_name(value)
            elif key == 'name':
                action.set_name(value)
            elif key == 'id':
                action.set_id(value)
            elif key == 'idref':
                action.set_idref(value)
            elif key == 'ordinal_position':
                action.set_ordinal_position(value)
            elif key == 'context':
                action.set_context(value)
            elif key == 'network_protocol':
                action.set_network_protocol(value)
            elif key == 'action_status':
                action.set_action_status(value)
            elif key == 'timestamp':
                action.set_timestamp(value)
            elif key == 'type':
                if value.count('/') > 0:
                    action.set_type(value)
                else:
                    action.set_type(value.capitalize())
            elif key == 'associated_objects':
                for associated_object in value:
                    if associated_object is not None: associated_objects.add_Associated_Object(value)
            elif key == 'object':
                if value is not None and value.hasContent_():
                    associated_objects.add_Associated_Object(value)
            elif key == 'object_old':
                if value is not None and value.hasContent_():
                    associated_objects.add_Associated_Object(value)
            elif key == 'object_new':
                if value is not None and value.hasContent_():
                    associated_objects.add_Associated_Object(value)
            #elif key == 'tool_id':
            #    discovery_method = maec.common.MeasureSourceType()
            #    tools = maec.common.ToolsInformationType()
            #    tool=maec.common.ToolInformationType(idref=value)
            #    tools.add_Tool(tool)
            #    discovery_method.set_Tools(tools)
            #    action.set_Discovery_Method(discovery_method)
            elif key == 'action_arguments':
                action_arguments = bundle_binding.cybox_core_1_0.ActionArgumentsType()
                for argument in value:
                    action_argument = bundle_binding.cybox_core_1_0.ActionArgumentType()
                    for key, value in argument.items():
                        if key == 'defined_argument_name':
                            action_argument.set_defined_argument_name(value)
                        elif key == 'undefined_argument_name':
                            action_argument.set_undefined_argument_name(value)
                        elif key == 'argument_value':
                            action_argument.set_argument_value(value)
                    action_arguments.add_Action_Argument(action_argument)
                if action_arguments.hasContent_():
                    action.set_Action_Arguments(action_arguments)
        if associated_objects.hasContent_():
            action.set_Associated_Objects(associated_objects)
        return action

    #Parse the action into a dictionary
    @classmethod
    def parse_into_dict(cls, action_attributes_dict = None):
        pass